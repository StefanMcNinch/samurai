<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Samurai - Multiplayer Board Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.1/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            min-height: 100vh;
            padding: 10px;
            user-select: none;
            overflow: hidden;
        }
        
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            gap: 20px;
            height: calc(100vh - 20px);
        }
        
        .left-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            width: 300px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .game-area {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        h1 {
            text-align: center;
            color: #d35400;
            margin-bottom: 20px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .connection-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .status {
            padding: 10px;
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .status.connected {
            background: #d4edda;
            border-left-color: #28a745;
        }
        
        .status.waiting {
            background: #fff3cd;
            border-left-color: #ffc107;
        }
        
        .room-link {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            word-break: break-all;
            font-size: 12px;
            border: 2px solid #dee2e6;
        }
        
        button {
            width: 100%;
            padding: 12px 15px;
            background: linear-gradient(135deg, #e67e22, #d35400);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(230, 126, 34, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .board-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        svg {
            width: 100%;
            height: 100%;
            background: #f0f0f0;
            border-radius: 10px;
        }
        
        .hex {
            cursor: pointer;
        }
        
        .draggable-tile {
            position: absolute;
            width: 60px;
            height: 52px;
            cursor: move;
            z-index: 100;
            background: transparent;
            border: none;
        }
        
        .draggable-tile.dragging {
            z-index: 1000;
            pointer-events: none;
        }
        
        .draggable-tile svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            background: transparent;
        }
        
        .draggable-token {
            position: absolute;
            width: 24px;
            height: 24px;
            cursor: move;
            z-index: 50;
        }
        
        .draggable-token.dragging {
            z-index: 999;
            pointer-events: none;
        }
        
        .draggable-token svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.4));
        }
        
        .deck-area {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            position: relative;
        }
        
        .deck {
            text-align: center;
            position: relative;
        }
        
        .deck-pile {
            width: 80px;
            height: 69px;
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            border: 3px solid #922b21;
            margin-bottom: 5px;
            position: relative;
        }
        
        .deck-pile.yellow-deck {
            background: linear-gradient(135deg, #f39c12, #f1c40f);
            border-color: #d68910;
        }
        
        .deck-pile.empty {
            opacity: 0.3;
        }
        
        .deck-label {
            font-size: 12px;
            color: #666;
        }
        
        .player-hand {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            min-height: 200px;
            position: relative;
            flex: 1;
            border: 2px dashed #ccc;
        }
        
        .hand-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
       .token-storage {
    position: absolute;
    top: 50%; /* Position from the top */
    right: 20px;
    transform: translateY(-50%); /* Pull it up by half its height to center it */
    background: rgba(255,255,255,0.9);
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}
        
        .token-storage-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #666;
        }
        
        .token-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .turn-indicator {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .opponent-hand-count {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .menu-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 400px;
        }
        
        .menu-content h1 {
            font-size: 3em;
            margin-bottom: 30px;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .room-input {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="menu-screen" id="menuScreen">
        <div class="menu-content">
            <h1>‰æç</h1>
            <div class="menu-buttons">
                <button onclick="createRoom()">Create New Game</button>
                <input type="text" class="room-input" id="roomCodeInput" placeholder="Enter room code">
                <button onclick="joinRoom()">Join Game</button>
                <button onclick="playSolo()">Play Solo (Test Mode)</button>
            </div>
        </div>
    </div>

    <div class="main-container hidden" id="gameContainer">
        <div class="left-panel">
            <h1>‰æç</h1>
            
            <div class="connection-panel">
                <div class="status" id="status">Waiting for connection...</div>
                <div id="roomInfo" class="hidden">
                    <div class="room-link" id="roomLink"></div>
                    <button onclick="copyRoomLink()">üìã Copy Game Link</button>
                </div>
            </div>
            
            <div id="gameBoard">
                <div class="deck-area" id="deckArea">
    <div class="deck">
        <div class="deck-pile red-deck" id="redDeck" onclick="drawFromDeck('red')">
            <span id="redCount">20</span>
        </div>
        <div class="deck-label">Red Deck</div>
    </div>
    <div class="deck">
        <div class="deck-pile yellow-deck" id="yellowDeck" onclick="drawFromDeck('yellow')">
            <span id="yellowCount">20</span>
        </div>
        <div class="deck-label">Yellow Deck</div>
    </div>
</div>
                
                <div class="player-hand" id="playerHand">
                    <div class="hand-title">Your Hand (Hidden from Opponent)</div>
                </div>
                
                <div class="opponent-hand-count">
                    Opponent's Hand: <strong id="opponentCount">0</strong> tiles
                </div>
            </div>
        </div>
        
        <div class="game-area" id="gameArea">
            <div class="game-info" id="gameInfo">
                <div class="turn-indicator" id="turnIndicator">Player 1's Turn</div>
                <button onclick="endTurn()" style="width: auto; padding: 8px 20px; margin: 0;">End Turn</button>
            </div>
            
            <div class="board-container" id="boardContainer">
                <svg id="board" viewBox="0 0 900 600">
                    <!-- Board will be generated here -->
                </svg>
                
                <div class="token-storage" id="tokenStorage">
                    <div class="token-storage-title">Tokens (drag to board)</div>
                    <div class="token-row" id="squareTokens"></div>
                    <div class="token-row" id="triangleTokens"></div>
                    <div class="token-row" id="circleTokens"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Room and connection variables
        let roomCode = null;
        let peer = null;
        let conn = null;
        let isHost = false;
        let myPlayer = null;
        
        // Game state
        let gameState = {
            board: [],
            redDeck: [],
            yellowDeck: [],
            tiles: [],
            tokens: [],
            currentTurn: 1
        };

        function drawFromDeck(deckColor) {
            // Check if it's the current player's turn
            if (myPlayer !== gameState.currentTurn) {
                alert("It is not your turn to draw a tile.");
                return;
            }

            let deck;
            if (deckColor === 'red' && gameState.redDeck.length > 0) {
                deck = gameState.redDeck;
            } else if (deckColor === 'yellow' && gameState.yellowDeck.length > 0) {
                deck = gameState.yellowDeck;
            } else {
                return; // Deck is empty or invalid
            }

            const drawnTile = deck.pop();
            myHandTiles.push(drawnTile);
            
            // Add the new tile to the player's hand visually
            const tileEl = createTileElement(drawnTile, false); // Create face-up, not face-down
            document.getElementById('playerHand').appendChild(tileEl);
            
            // Sync the game state to the opponent
            syncGameState();
            
        }
        // Local state
        let myHandTiles = [];
        let draggedElement = null;
        let dragOffset = {x: 0, y: 0};
        let tileIdCounter = 0;
        let tokenIdCounter = 0;
        
        // Board configuration
        const HEX_SIZE = 25;
        
        // Map layout
        const MAP_LAYOUT = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,2,0],
             [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],
            [0,0,0,0,0,0,0,0,0,1,2,1,2,1,2,0,0],
            [0,0,1,2,1,1,2,0,2,1,1,1,1,0,0,0],
             [0,0,2,1,1,2,1,1,1,1,1,5,1,2,0,0,0],
            [0,0,0,0,0,0,1,4,1,2,1,1,1,0,0,0],
            [0,0,0,0,0,0,2,1,0,0,0,0,2,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            
        ];
        
        // Tile types
        const TILE_TYPES = [
            {type: 'Any', value: 1},
            {type: 'Any', value: 1},
            {type: 'Any', value: 2},
            {type: 'Any', value: 2},
            {type: 'Any', value: 3},
            {type: 'Sqre', value: 2},
            {type: 'Sqre', value: 3},
            {type: 'Sqre', value: 4},
            {type: 'ship', value: 1},
            {type: 'ship', value: 1},
            {type: 'ship', value: 2},
            {type: 'Fast', value: 1},
            {type: 'Crcl', value: 2},
            {type: 'Crcl', value: 3},
            {type: 'Crcl', value: 4},
            {type: 'Swch', value: 0},
            {type: 'Move', value: 0},
            {type: 'Tri', value: 2},
            {type: 'Tri', value: 3},
            {type: 'Tri', value: 4}
        ];
        
        // Check URL for room code on load
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const urlRoom = urlParams.get('room');
            
            if (urlRoom) {
                document.getElementById('roomCodeInput').value = urlRoom;
                joinRoom();
            }
        });
        
        // Create a new room
        function createRoom() {
            roomCode = generateRoomCode();
            isHost = true;
            myPlayer = 1;
            
            // Update URL
            const url = new URL(window.location);
            url.searchParams.set('room', roomCode);
            window.history.pushState({}, '', url);
            
            initPeer(roomCode);
            showGame();
            
            // Show room link
            const roomLink = `${window.location.origin}${window.location.pathname}?room=${roomCode}`;
            document.getElementById('roomLink').textContent = roomLink;
            document.getElementById('roomInfo').classList.remove('hidden');
            document.getElementById('status').textContent = 'Waiting for opponent...';
            document.getElementById('status').classList.add('waiting');
        }
        
        // Join existing room
        function joinRoom() {
            const inputCode = document.getElementById('roomCodeInput').value.trim();
            if (!inputCode) {
                alert('Please enter a room code');
                return;
            }
            
            roomCode = inputCode;
            myPlayer = 2;
            
            // Update URL
            const url = new URL(window.location);
            url.searchParams.set('room', roomCode);
            window.history.pushState({}, '', url);
            
            initPeer();
            showGame();
            
            // Try to connect to host
            setTimeout(() => {
                connectToHost();
            }, 1000);
        }
        
        // Play solo mode
        function playSolo() {
            isHost = true;
            myPlayer = 1;
            showGame();
            initGame();
            document.getElementById('status').textContent = 'Playing Solo Mode';
            document.getElementById('status').classList.add('connected');
        }
        
        // Generate room code
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }
        
        // Show game screen
        function showGame() {
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameContainer').classList.remove('hidden');
        }
        
        // Initialize PeerJS
        function initPeer(customId = null) {
            const peerId = customId || 'samurai-' + Math.random().toString(36).substring(2, 9);
            
            peer = new Peer(peerId, {
                debug: 2
            });
            
            peer.on('open', (id) => {
                console.log('Connected with ID:', id);
                
                if (isHost) {
                    // Wait for connection
                    peer.on('connection', (connection) => {
                        conn = connection;
                        setupConnection();
                        document.getElementById('status').textContent = 'Opponent connected!';
                        document.getElementById('status').classList.remove('waiting');
                        document.getElementById('status').classList.add('connected');
                    });
                }
            });
            
            peer.on('error', (err) => {
                console.error('PeerJS Error:', err);
                if (err.type === 'peer-unavailable') {
                    document.getElementById('status').textContent = 'Room not found. Creating new game...';
                    setTimeout(() => {
                        createRoom();
                    }, 2000);
                }
            });
        }
        
        // Connect to host
        function connectToHost() {
            if (!peer) return;
            
            conn = peer.connect(roomCode);
            setupConnection();
        }
        
        // Setup connection
        function setupConnection() {
            conn.on('open', () => {
                document.getElementById('status').textContent = 'Connected!';
                document.getElementById('status').classList.add('connected');
                
                if (isHost) {
                    initGame();
                    syncGameState();
                }
            });
            
            conn.on('data', (data) => {
                handleMessage(data);
            });
            
            conn.on('close', () => {
                document.getElementById('status').textContent = 'Opponent disconnected';
                document.getElementById('status').classList.remove('connected');
            });
        }
        
        // Initialize game
        function initGame() {
            // Initialize board
            gameState.board = [];
            for (let row = 0; row < MAP_LAYOUT.length; row++) {
                for (let col = 0; col < MAP_LAYOUT[row].length; col++) {
                    gameState.board.push({
                        row: row,
                        col: col,
                        type: MAP_LAYOUT[row][col]
                    });
                }
            }
            
            // Create and shuffle decks
            gameState.redDeck = [...TILE_TYPES].map((t, i) => ({...t, id: 'r' + i, color: 'red'}));
            gameState.yellowDeck = [...TILE_TYPES].map((t, i) => ({...t, id: 'y' + i, color: 'yellow'}));
            shuffleArray(gameState.redDeck);
            shuffleArray(gameState.yellowDeck);
            
            gameState.tiles = [];
            gameState.tokens = [];
            
            drawBoard();
            createDeckTiles();
            createTokens();
            updateUI();
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
         function drawBoard() {
            const svg = document.getElementById('board');
            svg.innerHTML = '';
            
            gameState.board.forEach((hex, i) => {
                const x = hex.col * HEX_SIZE * 1.5 + 50;
                const y = hex.row * HEX_SIZE * 1.732 + (hex.col % 2) * HEX_SIZE * 0.866 + 50;
                
                const hexPath = createHexagon(x, y, HEX_SIZE);
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', hexPath);
                path.setAttribute('fill', hex.type === 0 ? '#5dade2' : '#90EE90');
                path.setAttribute('stroke', '#2c3e50');
                path.setAttribute('stroke-width', '1');
                path.setAttribute('class', 'hex');
                svg.appendChild(path);
                
                if (hex.type === 0) {
                    const wave = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    wave.setAttribute('x', x);
                    wave.setAttribute('y', y);
                    wave.setAttribute('text-anchor', 'middle');
                    wave.setAttribute('fill', '#3498db');
                    wave.setAttribute('font-size', '20');
                    wave.setAttribute('opacity', '0.3');
                    wave.textContent = '„Äú';
                    svg.appendChild(wave);
                }
                
                let pagodaCount = 0;
                if (hex.type === 2) {
                    pagodaCount = 1;
                } else if (hex.type === 4) {
                    pagodaCount = 2;
                } else if (hex.type === 5) {
                    pagodaCount = 3;
                }
                
                if (pagodaCount > 0) {
                    for (let p = 0; p < pagodaCount; p++) {
                        const pagoda = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        pagoda.setAttribute('x', x - (pagodaCount - 1) * 10 + p * 20);
                        pagoda.setAttribute('y', y + 5);
                        pagoda.setAttribute('text-anchor', 'middle');
                        pagoda.setAttribute('fill', '#c0392b');
                        pagoda.setAttribute('font-size', '24');
                        pagoda.textContent = '‚õ©';
                        svg.appendChild(pagoda);
                    }
                }
            });
        }
        
        function createHexagon(x, y, size) {
            const points = [];
            for (let i = 0; i < 6; i++) {
                // Correct calculation for point-up hexes
                const angle = (Math.PI / 3) * i;
                points.push([
                    x + size * Math.cos(angle),
                    y + size * Math.sin(angle)
                ]);
            }
            return 'M' + points.map(p => p.join(',')).join(' L') + ' Z';
        }
        
        function createDeckTiles() {
            const redDeck = document.getElementById('redDeck');
            const yellowDeck = document.getElementById('yellowDeck');
            
            // Clear any existing deck tiles
            document.querySelectorAll('#deckArea .draggable-tile').forEach(t => t.remove());
            
            // Stack red tiles
            gameState.redDeck.forEach((tile, index) => {
                const tileEl = createTileElement(tile, true);
                tileEl.style.left = (redDeck.offsetLeft + index * 0.5) + 'px';
                tileEl.style.top = (redDeck.offsetTop + index * 0.5) + 'px';
                tileEl.style.zIndex = index;
                tileEl.dataset.deckColor = 'red';
                document.getElementById('deckArea').appendChild(tileEl);
            });
            
            // Stack yellow tiles
            gameState.yellowDeck.forEach((tile, index) => {
                const tileEl = createTileElement(tile, true);
                tileEl.style.left = (yellowDeck.offsetLeft + 100 + index * 0.5) + 'px';
                tileEl.style.top = (yellowDeck.offsetTop + index * 0.5) + 'px';
                tileEl.style.zIndex = index;
                tileEl.dataset.deckColor = 'yellow';
                document.getElementById('deckArea').appendChild(tileEl);
            });
        }
        
        function createTileElement(tile, faceDown = false) {
            const tileDiv = document.createElement('div');
            tileDiv.className = 'draggable-tile';
            tileDiv.dataset.tileId = tile.id;
            tileDiv.dataset.faceDown = faceDown;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 60 52');
            
            const hexPath = createHexagon(30, 26, 25);
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', hexPath);
            
            if (faceDown) {
                path.setAttribute('fill', tile.color === 'red' ? '#c0392b' : '#d68910');
            } else {
                path.setAttribute('fill', tile.color === 'red' ? '#e74c3c' : '#f1c40f');
            }
            
            path.setAttribute('stroke', '#2c3e50');
            path.setAttribute('stroke-width', '2');
            
            svg.appendChild(path);
            
            if (!faceDown) {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', '30');
                text.setAttribute('y', '32');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', 'white');
                text.setAttribute('font-size', '14');
                text.setAttribute('font-weight', 'bold');
                text.textContent = tile.type.charAt(0).toUpperCase() + tile.value;
                svg.appendChild(text);
            }
            
            tileDiv.appendChild(svg);
            tileDiv.addEventListener('mousedown', startDragTile);
            tileDiv.addEventListener('contextmenu', flipTile);
            
            return tileDiv;
        }
        
        function createTokens() {
            const squareContainer = document.getElementById('squareTokens');
            const triangleContainer = document.getElementById('triangleTokens');
            const circleContainer = document.getElementById('circleTokens');
            
            for (let i = 0; i < 7; i++) {
                const square = createTokenElement('square', 's' + tokenIdCounter++);
                squareContainer.appendChild(square);
                
                const triangle = createTokenElement('triangle', 't' + tokenIdCounter++);
                triangleContainer.appendChild(triangle);
                
                const circle = createTokenElement('circle', 'c' + tokenIdCounter++);
                circleContainer.appendChild(circle);
            }
        }
        
        function createTokenElement(type, id) {
            const tokenDiv = document.createElement('div');
            tokenDiv.className = 'draggable-token';
            tokenDiv.dataset.tokenId = id;
            tokenDiv.dataset.tokenType = type;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            
            if (type === 'square') {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', '4');
                rect.setAttribute('y', '4');
                rect.setAttribute('width', '16');
                rect.setAttribute('height', '16');
                rect.setAttribute('fill', '#e74c3c');
                rect.setAttribute('stroke', '#c0392b');
                rect.setAttribute('stroke-width', '2');
                svg.appendChild(rect);
            } else if (type === 'triangle') {
                const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                triangle.setAttribute('points', '12,4 4,20 20,20');
                triangle.setAttribute('fill', '#3498db');
                triangle.setAttribute('stroke', '#2980b9');
                triangle.setAttribute('stroke-width', '2');
                svg.appendChild(triangle);
            } else {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', '12');
                circle.setAttribute('cy', '12');
                circle.setAttribute('r', '8');
                circle.setAttribute('fill', '#2ecc71');
                circle.setAttribute('stroke', '#27ae60');
                circle.setAttribute('stroke-width', '2');
                svg.appendChild(circle);
            }
            
            tokenDiv.appendChild(svg);
            tokenDiv.addEventListener('mousedown', startDragToken);
            
            return tokenDiv;
        }
        
        function startDragTile(e) {
            if (e.button !== 0) return;
            e.preventDefault();
            
            const tile = e.currentTarget;
            draggedElement = tile;
            
            const rect = tile.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            tile.classList.add('dragging');
            tile.style.zIndex = 1000;
            
            document.addEventListener('mousemove', dragMove);
            document.addEventListener('mouseup', dropTile);
        }
        
        function startDragToken(e) {
            if (e.button !== 0) return;
            e.preventDefault();
            
            const token = e.currentTarget;
            draggedElement = token;
            
            const rect = token.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            token.classList.add('dragging');
            
            document.addEventListener('mousemove', dragMove);
            document.addEventListener('mouseup', dropToken);
        }
        
        function dragMove(e) {
            if (!draggedElement) return;
            
            const container = draggedElement.parentElement;
            const rect = container.getBoundingClientRect();
            
            draggedElement.style.left = (e.clientX - rect.left - dragOffset.x) + 'px';
            draggedElement.style.top = (e.clientY - rect.top - dragOffset.y) + 'px';
        }
        
        function dropTile(e) {
            if (!draggedElement) return;
            
            const tile = draggedElement;
            tile.classList.remove('dragging');
            
            const handRect = document.getElementById('playerHand').getBoundingClientRect();
            if (e.clientX >= handRect.left && e.clientX <= handRect.right &&
                e.clientY >= handRect.top && e.clientY <= handRect.bottom) {
                
                if (tile.parentElement.id !== 'playerHand') {
                    document.getElementById('playerHand').appendChild(tile);
                    
                    if (tile.dataset.faceDown === 'true') {
                        tile.dataset.faceDown = 'false';
                        updateTileVisual(tile);
                    }
                }
            }
            else if (e.clientX >= document.getElementById('boardContainer').getBoundingClientRect().left) {
                if (tile.parentElement.id !== 'boardContainer') {
                    document.getElementById('boardContainer').appendChild(tile);
                }
            }
            
            updateStackOrder(e.clientX, e.clientY);
            
            draggedElement = null;
            document.removeEventListener('mousemove', dragMove);
            document.removeEventListener('mouseup', dropTile);
            
            syncGameState();
        }
        
        function dropToken(e) {
            if (!draggedElement) return;
            
            const token = draggedElement;
            token.classList.remove('dragging');
            
            const boardRect = document.getElementById('boardContainer').getBoundingClientRect();
            const tokenStorage = document.getElementById('tokenStorage').getBoundingClientRect();
            
            // Check if dropped on board (but not in token storage area)
            if (e.clientX >= boardRect.left && e.clientX <= boardRect.right &&
                e.clientY >= boardRect.top && e.clientY <= boardRect.bottom &&
                !(e.clientX >= tokenStorage.left && e.clientX <= tokenStorage.right &&
                  e.clientY >= tokenStorage.top && e.clientY <= tokenStorage.bottom)) {
                
                // Always append to boardContainer for tokens dropped on board
                document.getElementById('boardContainer').appendChild(token);
            } else if (e.clientX >= tokenStorage.left && e.clientX <= tokenStorage.right &&
                       e.clientY >= tokenStorage.top && e.clientY <= tokenStorage.bottom) {
                // Return to original storage container if dropped back in storage
                const tokenType = token.dataset.tokenType;
                if (tokenType === 'square') {
                    document.getElementById('squareTokens').appendChild(token);
                } else if (tokenType === 'triangle') {
                    document.getElementById('triangleTokens').appendChild(token);
                } else if (tokenType === 'circle') {
                    document.getElementById('circleTokens').appendChild(token);
                }
            }
            
            draggedElement = null;
            document.removeEventListener('mousemove', dragMove);
            document.removeEventListener('mouseup', dropToken);
            
            syncGameState();
        }
        
        function flipTile(e) {
            e.preventDefault();
            const tile = e.currentTarget;
            
            const faceDown = tile.dataset.faceDown === 'true';
            tile.dataset.faceDown = !faceDown;
            updateTileVisual(tile);
            
            return false;
        }
        
        function updateTileVisual(tileEl) {
            const tileId = tileEl.dataset.tileId;
            const faceDown = tileEl.dataset.faceDown === 'true';
            
            let tile = gameState.redDeck.find(t => t.id === tileId) || 
                      gameState.yellowDeck.find(t => t.id === tileId) ||
                      gameState.tiles.find(t => t.id === tileId);
            
            if (!tile) return;
            
            const svg = tileEl.querySelector('svg');
            const path = svg.querySelector('path');
            
            if (faceDown) {
                path.setAttribute('fill', tile.color === 'red' ? '#c0392b' : '#d68910');
                const text = svg.querySelector('text');
                if (text) text.remove();
            } else {
                path.setAttribute('fill', tile.color === 'red' ? '#e74c3c' : '#f1c40f');
                let text = svg.querySelector('text');
                if (!text) {
                    text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', '30');
                    text.setAttribute('y', '32');
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-size', '12');
                    text.setAttribute('font-weight', 'bold');
                    svg.appendChild(text);
                }
                // S=Samurai, H=Helmet, B=Buddha, Ship=Ship, E=Exchange, M=Move, Sp=Special
                let symbol = tile.type.charAt(0).toUpperCase();
                if (tile.type === 'ship') symbol = 'Ship';
                 if (tile.type === 'Any') symbol = 'Any';
                 if (tile.type === 'Crcl') symbol = 'Crcl';
                 if (tile.type === 'Sqre') symbol = 'Sqre';
                 if (tile.type === 'Tri') symbol = 'Tri';
                 if (tile.type === 'Fast') symbol = 'Fast';
                 if (tile.type === 'Move') symbol = 'Move';
                 if (tile.type === 'Swch') symbol = 'Swch';
                text.textContent = symbol + tile.value;
            }
        }
        
        function updateStackOrder(x, y) {
            const tiles = document.querySelectorAll('.draggable-tile');
            const nearbyTiles = [];
            
            tiles.forEach(tile => {
                const rect = tile.getBoundingClientRect();
                const tileCenterX = rect.left + rect.width / 2;
                const tileCenterY = rect.top + rect.height / 2;
                
                const distance = Math.sqrt(Math.pow(x - tileCenterX, 2) + Math.pow(y - tileCenterY, 2));
                if (distance < 30) {
                    nearbyTiles.push(tile);
                }
            });
            
            nearbyTiles.forEach((tile, index) => {
                tile.style.zIndex = 100 + index;
            });
        }
        
        function updateUI() {
            document.getElementById('redCount').textContent = gameState.redDeck.length;
            document.getElementById('yellowCount').textContent = gameState.yellowDeck.length;
            
            const redDeck = document.getElementById('redDeck');
            const yellowDeck = document.getElementById('yellowDeck');
            
            if (gameState.redDeck.length === 0) redDeck.classList.add('empty');
            if (gameState.yellowDeck.length === 0) yellowDeck.classList.add('empty');
            
            const turnText = `Player ${gameState.currentTurn}'s Turn`;
            document.getElementById('turnIndicator').textContent = turnText;
        }
        
        function endTurn() {
            gameState.currentTurn = gameState.currentTurn === 1 ? 2 : 1;
            updateUI();
            syncGameState();
        }
        
        function syncGameState() {
            if (!conn || !conn.open) return;
            
            const tiles = [];
            document.querySelectorAll('.draggable-tile').forEach(tile => {
                if (tile.parentElement.id === 'boardContainer') {
                    tiles.push({
                        id: tile.dataset.tileId,
                        x: tile.style.left,
                        y: tile.style.top,
                        faceDown: tile.dataset.faceDown === 'true',
                        zIndex: tile.style.zIndex
                    });
                }
            });
            
            const tokens = [];
            document.querySelectorAll('.draggable-token').forEach(token => {
                if (token.parentElement.id === 'boardContainer') {
                    tokens.push({
                        id: token.dataset.tokenId,
                        type: token.dataset.tokenType,
                        x: token.style.left,
                        y: token.style.top
                    });
                }
            });
            
            const handCount = document.querySelectorAll('#playerHand .draggable-tile').length;
            
            // Update local gameState before sending
            gameState.tiles = tiles;
            gameState.tokens = tokens;
            
            conn.send({
                type: 'gameState',
                data: {
                    ...gameState,
                    opponentHandCount: handCount
                }
            });
        }
        
        function handleMessage(msg) {
            switch (msg.type) {
                case 'gameState':
                    const newState = msg.data;
                    gameState = {...gameState, ...newState};
                    
                    updateBoardTiles(newState.tiles || []);
                    updateBoardTokens(newState.tokens || []);
                    
                    document.getElementById('opponentCount').textContent = newState.opponentHandCount || 0;
                    
                    drawBoard();
                    updateUI();
                    break;
            }
        }
        
        function updateBoardTiles(tiles) {
            document.querySelectorAll('#boardContainer .draggable-tile').forEach(tile => {
                tile.remove();
            });
            
            tiles.forEach(tileData => {
                // Use included tile data or recreate it
                let tile = tileData.tileData;
                if (!tile) {
                    tile = gameState.redDeck.find(t => t.id === tileData.id) || 
                          gameState.yellowDeck.find(t => t.id === tileData.id);
                    if (!tile) {
                        const color = tileData.id.startsWith('r') ? 'red' : 'yellow';
                        const index = parseInt(tileData.id.substring(1));
                        tile = {...TILE_TYPES[index], id: tileData.id, color: color};
                    }
                }
                
                const tileEl = createTileElement(tile, tileData.faceDown);
                tileEl.style.left = tileData.x;
                tileEl.style.top = tileData.y;
                tileEl.style.zIndex = tileData.zIndex;
                document.getElementById('boardContainer').appendChild(tileEl);
            });
        }
        
        function updateBoardTokens(tokens) {
            document.querySelectorAll('#boardContainer .draggable-token').forEach(token => {
                token.remove();
            });
            
            tokens.forEach(tokenData => {
                const tokenEl = createTokenElement(tokenData.type, tokenData.id);
                tokenEl.style.left = tokenData.x;
                tokenEl.style.top = tokenData.y;
                document.getElementById('boardContainer').appendChild(tokenEl);
            });
        }
        
        function copyRoomLink() {
            const roomLink = document.getElementById('roomLink').textContent;
            navigator.clipboard.writeText(roomLink);
            const btn = event.target;
            btn.textContent = '‚úÖ Copied!';
            setTimeout(() => {
                btn.textContent = 'üìã Copy Game Link';
            }, 2000);
        }
        
        // Prevent right-click context menu on tiles
        document.addEventListener('contextmenu', (e) => {
            if (e.target.closest('.draggable-tile')) {
                e.preventDefault();
                return false;
            }
        });
    </script>
</body>
</html>
