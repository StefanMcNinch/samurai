<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Samurai - Multiplayer Board Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.1/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            min-height: 100vh;
            padding: 10px;
            user-select: none;
            overflow: hidden;
        }
        
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            gap: 20px;
            height: calc(100vh - 20px);
        }
        
        .left-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            width: 300px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .game-area {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        h1 {
            text-align: center;
            color: #d35400;
            margin-bottom: 20px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .connection-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .status {
            padding: 8px;
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 12px;
            word-break: break-all;
        }
        
        .status.connected {
            background: #d4edda;
            border-left-color: #28a745;
        }
        
        input {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        button {
            padding: 8px 15px;
            background: #e67e22;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            margin-right: 5px;
        }
        
        button:hover:not(:disabled) {
            background: #d35400;
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #gameBoard {
            display: none;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .board-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        svg {
            width: 100%;
            height: 100%;
            background: #f0f0f0;
            border-radius: 10px;
        }
        
        .hex {
            cursor: pointer;
        }
        
        .draggable-tile {
            position: absolute;
            width: 60px;
            height: 52px;
            cursor: move;
            z-index: 100;
        }
        
        .draggable-tile.dragging {
            z-index: 1000;
            pointer-events: none;
        }
        
        .draggable-tile svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }
        
        .draggable-token {
            position: absolute;
            width: 24px;
            height: 24px;
            cursor: move;
            z-index: 50;
        }
        
        .draggable-token.dragging {
            z-index: 999;
            pointer-events: none;
        }
        
        .draggable-token svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.4));
        }
        
        .deck-area {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            position: relative;
        }
        
        .deck {
            text-align: center;
            position: relative;
        }
        
        .deck-pile {
            width: 80px;
            height: 69px;
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            border: 3px solid #922b21;
            margin-bottom: 5px;
            position: relative;
        }
        
        .deck-pile.yellow-deck {
            background: linear-gradient(135deg, #f39c12, #f1c40f);
            border-color: #d68910;
        }
        
        .deck-pile.empty {
            opacity: 0.3;
        }
        
        .deck-label {
            font-size: 12px;
            color: #666;
        }
        
        .player-hand {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            min-height: 200px;
            position: relative;
            flex: 1;
            border: 2px dashed #ccc;
        }
        
        .hand-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .token-storage {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        
        .token-storage-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #666;
        }
        
        .token-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .tile-stack {
            position: absolute;
        }
        
        .tile-in-stack {
            position: absolute;
            pointer-events: auto;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .turn-indicator {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .opponent-hand-count {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="left-panel">
            <h1>‰æç</h1>
            
            <div class="connection-panel">
                <div class="status" id="status">Your ID: <span id="myId">Connecting...</span></div>
                <input type="text" id="peerId" placeholder="Enter friend's ID">
                <button onclick="connectToPeer()">Connect</button>
                <button onclick="copyId()">Copy ID</button>
            </div>
            
            <div id="gameBoard">
                <div class="deck-area" id="deckArea">
                    <div class="deck">
                        <div class="deck-pile red-deck" id="redDeck">
                            <span id="redCount">20</span>
                        </div>
                        <div class="deck-label">Red Deck</div>
                    </div>
                    <div class="deck">
                        <div class="deck-pile yellow-deck" id="yellowDeck">
                            <span id="yellowCount">20</span>
                        </div>
                        <div class="deck-label">Yellow Deck</div>
                    </div>
                </div>
                
                <div class="player-hand" id="playerHand">
                    <div class="hand-title">Your Hand (Hidden from Opponent)</div>
                </div>
                
                <div class="opponent-hand-count">
                    Opponent's Hand: <strong id="opponentCount">0</strong> tiles
                </div>
            </div>
        </div>
        
        <div class="game-area" id="gameArea">
            <div class="game-info" id="gameInfo" style="display: none;">
                <div class="turn-indicator" id="turnIndicator">Your Turn</div>
                <button onclick="endTurn()">End Turn</button>
            </div>
            
            <div class="board-container" id="boardContainer">
                <svg id="board" viewBox="0 0 800 600">
                    <!-- Board will be generated here -->
                </svg>
                
                <div class="token-storage" id="tokenStorage">
                    <div class="token-storage-title">Tokens (drag to board)</div>
                    <div class="token-row" id="squareTokens"></div>
                    <div class="token-row" id="triangleTokens"></div>
                    <div class="token-row" id="circleTokens"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // PeerJS variables
        let peer = null;
        let conn = null;
        let myId = null;
        let isHost = false;
        let myPlayer = null;
        let currentPlayer = 1;
        
        // Game state
        let gameState = {
            board: [],
            redDeck: [],
            yellowDeck: [],
            tiles: [], // All tiles on board
            tokens: [], // All tokens
            currentTurn: 1
        };
        
        // Local state (not synced)
        let myHandTiles = [];
        let draggedElement = null;
        let dragOffset = {x: 0, y: 0};
        let tileIdCounter = 0;
        let tokenIdCounter = 0;
        
        // Board configuration
        const HEX_SIZE = 25;
        const BOARD_WIDTH = 800;
        const BOARD_HEIGHT = 600;
        
        // Map layout (1 = land, 0 = water, 2 = pagoda)
        const MAP_LAYOUT = [
            [0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,1,0,0,0],
            [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [1,1,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,2,1,1,1,1,1,2,1,1,1,2,1,1,1,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        ];
        
        // Tile types
        const TILE_TYPES = [
            {type: 'samurai', value: 1},
            {type: 'samurai', value: 2},
            {type: 'samurai', value: 3},
            {type: 'helmet', value: 1},
            {type: 'helmet', value: 2},
            {type: 'helmet', value: 3},
            {type: 'helmet', value: 4},
            {type: 'helmet', value: 5},
            {type: 'ship', value: 1},
            {type: 'ship', value: 2},
            {type: 'ship', value: 3},
            {type: 'buddha', value: 1},
            {type: 'buddha', value: 2},
            {type: 'buddha', value: 3},
            {type: 'buddha', value: 4},
            {type: 'exchange', value: 0},
            {type: 'move', value: 0},
            {type: 'special', value: 1},
            {type: 'special', value: 2},
            {type: 'special', value: 3}
        ];
        
        // Initialize PeerJS
        function initPeer() {
            peer = new Peer();
            
            peer.on('open', (id) => {
                myId = id;
                document.getElementById('myId').textContent = id;
                document.getElementById('status').classList.add('connected');
            });
            
            peer.on('connection', (connection) => {
                if (!conn) {
                    conn = connection;
                    isHost = true;
                    myPlayer = 1;
                    setupConnection();
                }
            });
        }
        
        function connectToPeer() {
            const peerId = document.getElementById('peerId').value;
            if (!peerId) return;
            
            conn = peer.connect(peerId);
            myPlayer = 2;
            setupConnection();
        }
        
        function setupConnection() {
            conn.on('open', () => {
                document.getElementById('status').textContent = 'Connected!';
                document.getElementById('status').classList.add('connected');
                document.getElementById('gameBoard').style.display = 'flex';
                document.getElementById('gameInfo').style.display = 'flex';
                
                if (isHost) {
                    initGame();
                    syncGameState();
                }
            });
            
            conn.on('data', (data) => {
                handleMessage(data);
            });
        }
        
        function initGame() {
            // Initialize board
            gameState.board = [];
            for (let row = 0; row < MAP_LAYOUT.length; row++) {
                for (let col = 0; col < MAP_LAYOUT[row].length; col++) {
                    gameState.board.push({
                        row: row,
                        col: col,
                        type: MAP_LAYOUT[row][col]
                    });
                }
            }
            
            // Create and shuffle decks
            gameState.redDeck = [...TILE_TYPES].map((t, i) => ({...t, id: 'r' + i, color: 'red'}));
            gameState.yellowDeck = [...TILE_TYPES].map((t, i) => ({...t, id: 'y' + i, color: 'yellow'}));
            shuffleArray(gameState.redDeck);
            shuffleArray(gameState.yellowDeck);
            
            // Initialize tiles and tokens as empty arrays
            gameState.tiles = [];
            gameState.tokens = [];
            
            drawBoard();
            createDeckTiles();
            createTokens();
            updateUI();
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function drawBoard() {
            const svg = document.getElementById('board');
            svg.innerHTML = '';
            
            // Draw hexagons
            gameState.board.forEach((hex, i) => {
                const x = hex.col * HEX_SIZE * 1.5 + 50;
                const y = hex.row * HEX_SIZE * 1.732 + (hex.col % 2) * HEX_SIZE * 0.866 + 50;
                
                // Draw hex
                const hexPath = createHexagon(x, y, HEX_SIZE);
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', hexPath);
                path.setAttribute('fill', hex.type === 0 ? '#5dade2' : '#f4d03f');
                path.setAttribute('stroke', '#2c3e50');
                path.setAttribute('stroke-width', '1');
                path.setAttribute('class', 'hex');
                path.setAttribute('data-index', i);
                svg.appendChild(path);
                
                // Draw water pattern
                if (hex.type === 0) {
                    const wave = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    wave.setAttribute('x', x);
                    wave.setAttribute('y', y);
                    wave.setAttribute('text-anchor', 'middle');
                    wave.setAttribute('fill', '#3498db');
                    wave.setAttribute('font-size', '20');
                    wave.setAttribute('opacity', '0.3');
                    wave.textContent = '„Äú';
                    svg.appendChild(wave);
                }
                
                // Draw pagoda
                if (hex.type === 2) {
                    const pagoda = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    pagoda.setAttribute('x', x);
                    pagoda.setAttribute('y', y + 5);
                    pagoda.setAttribute('text-anchor', 'middle');
                    pagoda.setAttribute('fill', '#c0392b');
                    pagoda.setAttribute('font-size', '24');
                    pagoda.textContent = '‚õ©';
                    svg.appendChild(pagoda);
                }
            });
        }
        
        function createHexagon(x, y, size) {
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                points.push([
                    x + size * Math.cos(angle),
                    y + size * Math.sin(angle)
                ]);
            }
            return 'M' + points.map(p => p.join(',')).join(' L') + ' Z';
        }
        
        function createDeckTiles() {
            // Create visual tiles for each deck
            const redDeck = document.getElementById('redDeck');
            const yellowDeck = document.getElementById('yellowDeck');
            
            // Stack red tiles
            gameState.redDeck.forEach((tile, index) => {
                const tileEl = createTileElement(tile, true);
                tileEl.style.left = (redDeck.offsetLeft + index * 0.5) + 'px';
                tileEl.style.top = (redDeck.offsetTop + index * 0.5) + 'px';
                tileEl.style.zIndex = index;
                document.getElementById('deckArea').appendChild(tileEl);
            });
            
            // Stack yellow tiles
            gameState.yellowDeck.forEach((tile, index) => {
                const tileEl = createTileElement(tile, true);
                tileEl.style.left = (yellowDeck.offsetLeft + index * 0.5) + 'px';
                tileEl.style.top = (yellowDeck.offsetTop + index * 0.5) + 'px';
                tileEl.style.zIndex = index;
                document.getElementById('deckArea').appendChild(tileEl);
            });
        }
        
        function createTileElement(tile, faceDown = false) {
            const tileDiv = document.createElement('div');
            tileDiv.className = 'draggable-tile';
            tileDiv.dataset.tileId = tile.id;
            tileDiv.dataset.faceDown = faceDown;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 60 52');
            
            const hexPath = createHexagon(30, 26, 25);
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', hexPath);
            
            if (faceDown) {
                path.setAttribute('fill', tile.color === 'red' ? '#c0392b' : '#d68910');
                // Remove text if exists
                const text = svg.querySelector('text');
                if (text) text.remove();
            } else {
                path.setAttribute('fill', tile.color === 'red' ? '#e74c3c' : '#f1c40f');
                // Add text if not exists
                let text = svg.querySelector('text');
                if (!text) {
                    text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', '30');
                    text.setAttribute('y', '32');
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-size', '14');
                    text.setAttribute('font-weight', 'bold');
                    svg.appendChild(text);
                }
                text.textContent = tile.type.charAt(0).toUpperCase() + tile.value;
            }
        }
        
        function updateStackOrder(x, y) {
            // Find all tiles at this position and update z-index for stacking
            const tiles = document.querySelectorAll('.draggable-tile');
            const nearbyTiles = [];
            
            tiles.forEach(tile => {
                const rect = tile.getBoundingClientRect();
                const tileCenterX = rect.left + rect.width / 2;
                const tileCenterY = rect.top + rect.height / 2;
                
                const distance = Math.sqrt(Math.pow(x - tileCenterX, 2) + Math.pow(y - tileCenterY, 2));
                if (distance < 30) {
                    nearbyTiles.push(tile);
                }
            });
            
            // Update z-index for stacking
            nearbyTiles.forEach((tile, index) => {
                tile.style.zIndex = 100 + index;
            });
        }
        
        function updateUI() {
            document.getElementById('redCount').textContent = gameState.redDeck.length;
            document.getElementById('yellowCount').textContent = gameState.yellowDeck.length;
            
            const redDeck = document.getElementById('redDeck');
            const yellowDeck = document.getElementById('yellowDeck');
            
            if (gameState.redDeck.length === 0) redDeck.classList.add('empty');
            if (gameState.yellowDeck.length === 0) yellowDeck.classList.add('empty');
            
            const turnText = gameState.currentTurn === myPlayer ? 'Your Turn' : "Opponent's Turn";
            document.getElementById('turnIndicator').textContent = turnText;
        }
        
        function endTurn() {
            gameState.currentTurn = gameState.currentTurn === 1 ? 2 : 1;
            updateUI();
            syncGameState();
        }
        
        function syncGameState() {
            if (!conn || !conn.open) return;
            
            // Collect all tiles positions
            const tiles = [];
            document.querySelectorAll('.draggable-tile').forEach(tile => {
                if (tile.parentElement.id === 'boardContainer') {
                    tiles.push({
                        id: tile.dataset.tileId,
                        x: tile.style.left,
                        y: tile.style.top,
                        faceDown: tile.dataset.faceDown === 'true',
                        zIndex: tile.style.zIndex
                    });
                }
            });
            
            // Collect all tokens positions
            const tokens = [];
            document.querySelectorAll('.draggable-token').forEach(token => {
                if (token.parentElement.id === 'boardContainer') {
                    tokens.push({
                        id: token.dataset.tokenId,
                        type: token.dataset.tokenType,
                        x: token.style.left,
                        y: token.style.top
                    });
                }
            });
            
            // Count hand tiles (don't send actual tiles, just count)
            const handCount = document.querySelectorAll('#playerHand .draggable-tile').length;
            
            conn.send({
                type: 'gameState',
                data: {
                    ...gameState,
                    tiles: tiles,
                    tokens: tokens,
                    opponentHandCount: handCount
                }
            });
        }
        
        function handleMessage(msg) {
            switch (msg.type) {
                case 'gameState':
                    const newState = msg.data;
                    gameState = {...gameState, ...newState};
                    
                    // Update board tiles
                    updateBoardTiles(newState.tiles || []);
                    
                    // Update board tokens
                    updateBoardTokens(newState.tokens || []);
                    
                    // Update opponent hand count
                    document.getElementById('opponentCount').textContent = newState.opponentHandCount || 0;
                    
                    drawBoard();
                    updateUI();
                    break;
            }
        }
        
        function updateBoardTiles(tiles) {
            // Remove existing board tiles (not in hand)
            document.querySelectorAll('#boardContainer .draggable-tile').forEach(tile => {
                tile.remove();
            });
            
            // Add tiles from game state
            tiles.forEach(tileData => {
                let tile = gameState.redDeck.find(t => t.id === tileData.id) || 
                          gameState.yellowDeck.find(t => t.id === tileData.id);
                
                if (tile) {
                    const tileEl = createTileElement(tile, tileData.faceDown);
                    tileEl.style.left = tileData.x;
                    tileEl.style.top = tileData.y;
                    tileEl.style.zIndex = tileData.zIndex;
                    document.getElementById('boardContainer').appendChild(tileEl);
                }
            });
        }
        
        function updateBoardTokens(tokens) {
            // Remove existing board tokens
            document.querySelectorAll('#boardContainer .draggable-token').forEach(token => {
                token.remove();
            });
            
            // Add tokens from game state
            tokens.forEach(tokenData => {
                const tokenEl = createTokenElement(tokenData.type, tokenData.id);
                tokenEl.style.left = tokenData.x;
                tokenEl.style.top = tokenData.y;
                document.getElementById('boardContainer').appendChild(tokenEl);
            });
        }
        
        function copyId() {
            navigator.clipboard.writeText(myId);
            const btn = event.target;
            btn.textContent = 'Copied!';
            setTimeout(() => {
                btn.textContent = 'Copy ID';
            }, 2000);
        }
        
        // Prevent right-click context menu globally
        document.addEventListener('contextmenu', (e) => {
            if (e.target.closest('.draggable-tile')) {
                e.preventDefault();
                return false;
            }
        });
        
        // Initialize on load with fallback
        window.addEventListener('load', () => {
            initPeer();
            
            // Add offline mode button for testing
            const offlineBtn = document.createElement('button');
            offlineBtn.textContent = 'Test Offline';
            offlineBtn.onclick = () => {
                document.getElementById('gameBoard').style.display = 'flex';
                document.getElementById('gameInfo').style.display = 'flex';
                myPlayer = 1;
                isHost = true;
                initGame();
            };
            document.querySelector('.connection-panel').appendChild(offlineBtn);
        });392b' : '#d68910');
            } else {
                path.setAttribute('fill', tile.color === 'red' ? '#e74c3c' : '#f1c40f');
            }
            
            path.setAttribute('stroke', '#2c3e50');
            path.setAttribute('stroke-width', '2');
            
            svg.appendChild(path);
            
            if (!faceDown) {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', '30');
                text.setAttribute('y', '32');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', 'white');
                text.setAttribute('font-size', '14');
                text.setAttribute('font-weight', 'bold');
                text.textContent = tile.type.charAt(0).toUpperCase() + tile.value;
                svg.appendChild(text);
            }
            
            tileDiv.appendChild(svg);
            
            // Add drag handlers
            tileDiv.addEventListener('mousedown', startDragTile);
            tileDiv.addEventListener('contextmenu', flipTile);
            
            return tileDiv;
        }
        
        function createTokens() {
            const squareContainer = document.getElementById('squareTokens');
            const triangleContainer = document.getElementById('triangleTokens');
            const circleContainer = document.getElementById('circleTokens');
            
            // Create 7 of each token type
            for (let i = 0; i < 7; i++) {
                // Square tokens
                const square = createTokenElement('square', 's' + tokenIdCounter++);
                squareContainer.appendChild(square);
                
                // Triangle tokens
                const triangle = createTokenElement('triangle', 't' + tokenIdCounter++);
                triangleContainer.appendChild(triangle);
                
                // Circle tokens
                const circle = createTokenElement('circle', 'c' + tokenIdCounter++);
                circleContainer.appendChild(circle);
            }
        }
        
        function createTokenElement(type, id) {
            const tokenDiv = document.createElement('div');
            tokenDiv.className = 'draggable-token';
            tokenDiv.dataset.tokenId = id;
            tokenDiv.dataset.tokenType = type;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            
            if (type === 'square') {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', '4');
                rect.setAttribute('y', '4');
                rect.setAttribute('width', '16');
                rect.setAttribute('height', '16');
                rect.setAttribute('fill', '#e74c3c');
                rect.setAttribute('stroke', '#c0392b');
                rect.setAttribute('stroke-width', '2');
                svg.appendChild(rect);
            } else if (type === 'triangle') {
                const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                triangle.setAttribute('points', '12,4 4,20 20,20');
                triangle.setAttribute('fill', '#3498db');
                triangle.setAttribute('stroke', '#2980b9');
                triangle.setAttribute('stroke-width', '2');
                svg.appendChild(triangle);
            } else {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', '12');
                circle.setAttribute('cy', '12');
                circle.setAttribute('r', '8');
                circle.setAttribute('fill', '#2ecc71');
                circle.setAttribute('stroke', '#27ae60');
                circle.setAttribute('stroke-width', '2');
                svg.appendChild(circle);
            }
            
            tokenDiv.appendChild(svg);
            tokenDiv.addEventListener('mousedown', startDragToken);
            
            return tokenDiv;
        }
        
        function startDragTile(e) {
            if (e.button !== 0) return; // Only left click
            e.preventDefault();
            
            const tile = e.currentTarget;
            draggedElement = tile;
            
            const rect = tile.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            tile.classList.add('dragging');
            tile.style.zIndex = 1000;
            
            document.addEventListener('mousemove', dragMove);
            document.addEventListener('mouseup', dropTile);
        }
        
        function startDragToken(e) {
            if (e.button !== 0) return;
            e.preventDefault();
            
            const token = e.currentTarget;
            draggedElement = token;
            
            const rect = token.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            token.classList.add('dragging');
            
            document.addEventListener('mousemove', dragMove);
            document.addEventListener('mouseup', dropToken);
        }
        
        function dragMove(e) {
            if (!draggedElement) return;
            
            const container = draggedElement.parentElement;
            const rect = container.getBoundingClientRect();
            
            draggedElement.style.left = (e.clientX - rect.left - dragOffset.x) + 'px';
            draggedElement.style.top = (e.clientY - rect.top - dragOffset.y) + 'px';
        }
        
        function dropTile(e) {
            if (!draggedElement) return;
            
            const tile = draggedElement;
            tile.classList.remove('dragging');
            
            // Check if dropped in player hand
            const handRect = document.getElementById('playerHand').getBoundingClientRect();
            if (e.clientX >= handRect.left && e.clientX <= handRect.right &&
                e.clientY >= handRect.top && e.clientY <= handRect.bottom) {
                
                // Move to hand
                if (tile.parentElement.id !== 'playerHand') {
                    document.getElementById('playerHand').appendChild(tile);
                    
                    // Flip face up when added to hand
                    if (tile.dataset.faceDown === 'true') {
                        tile.dataset.faceDown = 'false';
                        updateTileVisual(tile);
                    }
                }
            }
            // Check if dropped on board
            else if (e.clientX >= document.getElementById('boardContainer').getBoundingClientRect().left) {
                if (tile.parentElement.id !== 'boardContainer') {
                    document.getElementById('boardContainer').appendChild(tile);
                }
            }
            
            // Update z-index for stacking
            updateStackOrder(e.clientX, e.clientY);
            
            draggedElement = null;
            document.removeEventListener('mousemove', dragMove);
            document.removeEventListener('mouseup', dropTile);
            
            syncGameState();
        }
        
        function dropToken(e) {
            if (!draggedElement) return;
            
            const token = draggedElement;
            token.classList.remove('dragging');
            
            // Move to board if dropped there
            const boardRect = document.getElementById('boardContainer').getBoundingClientRect();
            if (e.clientX >= boardRect.left && e.clientX <= boardRect.right &&
                e.clientY >= boardRect.top && e.clientY <= boardRect.bottom) {
                
                if (token.parentElement.id !== 'boardContainer') {
                    document.getElementById('boardContainer').appendChild(token);
                }
            }
            
            draggedElement = null;
            document.removeEventListener('mousemove', dragMove);
            document.removeEventListener('mouseup', dropToken);
            
            syncGameState();
        }
        
        function flipTile(e) {
            e.preventDefault();
            const tile = e.currentTarget;
            
            const faceDown = tile.dataset.faceDown === 'true';
            tile.dataset.faceDown = !faceDown;
            updateTileVisual(tile);
            
            return false;
        }
        
        function updateTileVisual(tileEl) {
            const tileId = tileEl.dataset.tileId;
            const faceDown = tileEl.dataset.faceDown === 'true';
            
            // Find tile data
            let tile = gameState.redDeck.find(t => t.id === tileId) || 
                      gameState.yellowDeck.find(t => t.id === tileId) ||
                      gameState.tiles.find(t => t.id === tileId);
            
            if (!tile) return;
            
            const svg = tileEl.querySelector('svg');
            const path = svg.querySelector('path');
            
            if (faceDown) {
                path.setAttribute('fill', tile.color === 'red' ? '#c0
